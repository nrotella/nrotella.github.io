---
layout: post
title: "URDF, Kinematics, and KDL"
author: "Nick Rotella"
categories: journal
tags: [tutorial,python,qt,opengl,robotsim]
image: ARM.svg
---

(The goal of this post is to transition the robot sim from using DH parameters which are very clunky and limited, to an expressive format like URDF. The inspiration for this is KDL.)
* Table of contents:
{:toc}

In ROS, kinematics are handled as follows. The URDF (XML) file is first loaded into one big string parameter called "robot_description" in the ROS parameter server, and then the [robot_state_publisher(https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher_node.cpp) node is used to populate the transform tree.

Within the robot_state_publisher node, the string is first [used initialize a URDF model](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher_node.cpp#L58) with the [parseURDF()](https://github.com/ros/urdfdom/blob/master/urdf_parser/src/model.cpp#L91] function. This basically crawls through the XML string and pulls out the various elements (links, joints, materials, etc) and stores them in a ```urdf::ModelInterface``` object (or maybe actually a [urdf::Model](https://github.com/ros/urdf/blob/melodic-devel/urdf/include/urdf/model.h) object instead? Model derives from ModelInterface, but I didn't look into the distinctions). Along the way, [parseURDF() also builds a "tree" as a ```std::map<std::string, std::string>``` object to store link relationships](https://github.com/ros/urdfdom/blob/master/urdf_parser/src/model.cpp#L240-L255) using the [initTree()](https://github.com/ros/urdfdom_headers/blob/master/urdf_model/include/urdf_model/model.h#L113-L156) function. The [root link of the tree is then initialized](https://github.com/ros/urdfdom_headers/blob/master/urdf_model/include/urdf_model/model.h#L158-L184) and stored in the returned model.

Once the model has been initialized, it's [used to build a KDL tree](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher_node.cpp#L61-L65) using the [kdl_parser](http://wiki.ros.org/kdl_parser) package's functionality. There are several functions to build the KDL tree directly from a string or parameter here as well, but they all first convert to a ```urdf::Model``` as above and then pass the model to the [treeFromUrdfModel()](https://github.com/ros/kdl_parser/blob/noetic-devel/kdl_parser/src/kdl_parser.cpp#L230-L253) function. This initializes a [KDL kinematic tree](https://www.orocos.org/wiki/main-page/kdl-wiki/user-manual/kinematic-chains/kinematic-chains-kdl-11x.html) and then [recursively walks the tree to populate it with children](https://github.com/ros/kdl_parser/blob/noetic-devel/kdl_parser/src/kdl_parser.cpp#L141-L170). (NOTE: this is very similar to what we saw the [pytorch_kinematics](https://github.com/UM-ARM-Lab/pytorch_kinematics/blob/4597d76dc76e7f91bd47be8e39e3253c9d82c420/pytorch_kinematics/chain.py#L119-L127) library does). Note that KDL has [great documentation explaining how it relates Joint, Segment, Chain, and Tree objects under the hood, with diagrams](https://www.orocos.org/book/export/html/800.html).

Popping off the stack trace as it were back to [robot_state_publisher](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher_node.cpp#L75), we see that a [robot_state_publisher::JointStateListener](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/joint_state_listener.cpp#L55-L58) object actually gets created from the KDL tree and URDF model (and something weird called a mimic map?), which in turn creates the actual core [RobotStatePublisher](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher.cpp#L52-L57) object as a shared pointer. In the RSP's constructor, we see that the KDL tree's segments are iterated over and added into [maps of strings to SegmentPairs](https://github.com/ros/robot_state_publisher/blob/noetic-devel/include/robot_state_publisher/robot_state_publisher.h#L89), where [SegmentPair](https://github.com/ros/robot_state_publisher/blob/noetic-devel/include/robot_state_publisher/robot_state_publisher.h#L53-L61) is a simple class to hold the KDL segment itself with the "root" and "tip" names which define it. With the RSP defined inside the JointStateListener, the listener subscribes to the "joint_states" ROS message which is assumed to be published by some other node which reads the joint values. In the [joint state message callback](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/joint_state_listener.cpp#L100-L160), the listener checks the joint states before finally passing the joint state vector to [RobotStatePublisher::publishTransforms()](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher.cpp#L95-L115). This function uses the joint state name to look up the appropriate SegmentPair, and pass the joint state value to its KDL::Segment member, returning the pose of that segment's "tip" in its "root" frame; this is then [converted from a KDL::Frame to a TF2 transform stamped message](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher.cpp#L104) using the [tf2::kdlToTransform()](https://github.com/ros/geometry2/blob/noetic-devel/tf2_kdl/include/tf2_kdl/tf2_kdl.h#L58-L71) conversion function. The transform for each segment is pushed back into the tf tree, and [broadcasted](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher.cpp#L114) all at once. Note that for "fixed" transforms (those which do not change with changes in the joint state, e.g., rigid sensor mounts) there is a [separate RSP function](https://github.com/ros/robot_state_publisher/blob/noetic-devel/src/robot_state_publisher.cpp#L117-L141) to compute them (passing zero as the joint angle to the KDL::Segment for each) and broadcast.

That's it! So now you know how ROS parses a URDF all the way from XML to tf2 transform messages. It's important to note that the tf2 library doesn't actually deal with *computing* the transforms -- this is done entirely by the RSP and underlying KDL functuonality. Instead, tf2 is just *managing* the transforms and buffering them, exposing them to the user via answering frame transform queries between specific links at specific times, supplying the tree to RViz for robot visualization, etc. Of course, you can [compute and broadcast transforms yourself with tf2](http://wiki.ros.org/tf2/Tutorials/Writing%20a%20tf2%20broadcaster%20%28C%2B%2B%29) instead of using the URDF to KDL pipeline via the RSP, and in some cases you may want to do this in order to override transform values.